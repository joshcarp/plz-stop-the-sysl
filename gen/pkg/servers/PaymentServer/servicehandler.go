// Code generated by sysl DO NOT EDIT.
package paymentserver

import (
	"database/sql"
	"encoding/json"
	"net/http"

	"github.com/anz-bank/conf-demo/gen/pkg/servers/PaymentServer/mastercard"
	"github.com/anz-bank/conf-demo/gen/pkg/servers/PaymentServer/visa"
	"github.com/anz-bank/sysl-go/common"
	"github.com/anz-bank/sysl-go/core"
	"github.com/anz-bank/sysl-go/database"
	"github.com/anz-bank/sysl-go/restlib"
	"github.com/anz-bank/sysl-go/validator"
	_ "github.com/mattn/go-sqlite3"
)

// Handler interface for PaymentServer
type Handler interface {
	GetBalanceListHandler(w http.ResponseWriter, r *http.Request)
	PostPayHandler(w http.ResponseWriter, r *http.Request)
}

// ServiceHandler for PaymentServer API
type ServiceHandler struct {
	genCallback                 core.RestGenCallback
	serviceInterface            *ServiceInterface
	DB                          *sql.DB
	mastercardMastercardService mastercard.Service
	visaVisaService             visa.Service
}

// NewServiceHandler for PaymentServer
func NewServiceHandler(
	genCallback core.RestGenCallback,
	serviceInterface *ServiceInterface,
	mastercardMastercardService mastercard.Service,
	visaVisaService visa.Service,
) (*ServiceHandler, error) {
	db, dberr := database.GetDBHandle()
	if dberr != nil {
		return nil, dberr
	}

	return &ServiceHandler{
		genCallback,
		serviceInterface,
		db,
		mastercardMastercardService,
		visaVisaService,
	}, nil
}

// GetBalanceListHandler ...
func (s *ServiceHandler) GetBalanceListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetBalanceList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetBalanceListRequest

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	conn, dberr := s.DB.Conn(ctx)
	if dberr != nil {
		common.HandleError(ctx, w, common.InternalError, "Database connection could not be retrieved", dberr, s.genCallback.MapError)
		return
	}

	defer conn.Close()
	getBalanceStmt, dberr := conn.PrepareContext(ctx, `
		SELECT balance
		FROM   Account
		WHERE  accountID = 1
		`)
	if dberr != nil {
		common.HandleError(ctx, w, common.InternalError, "could not parse the sql query with the name getBalance", dberr, s.genCallback.MapError)
		return
	}

	insertBalanceStmt, dberr := conn.PrepareContext(ctx, `
		INSERT INTO Account (accountID, balance)
		VALUES (?, ?)
		`)
	if dberr != nil {
		common.HandleError(ctx, w, common.InternalError, "could not parse the sql query with the name insertBalance", dberr, s.genCallback.MapError)
		return
	}

	tx, dberr := conn.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if dberr != nil {
		common.HandleError(ctx, w, common.DownstreamUnavailableError, "DB Transaction could not be created", dberr, s.genCallback.MapError)
		return
	}

	client := GetBalanceListClient{

		Conn:          conn,
		GetBalance:    getBalanceStmt,
		InsertBalance: insertBalanceStmt,
	}

	balance, err := s.serviceInterface.GetBalanceList(ctx, &req, client)
	if err != nil {
		tx.Rollback()
		common.HandleError(ctx, w, common.DownstreamUnexpectedResponseError, "Downstream failure", err, s.genCallback.MapError)
		return
	}

	commitErr := tx.Commit()
	if commitErr != nil {
		common.HandleError(ctx, w, common.InternalError, "Failed to commit the transaction", commitErr, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, balance)
}

// PostPayHandler ...
func (s *ServiceHandler) PostPayHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.PostPay == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req PostPayRequest
	decoder := json.NewDecoder(r.Body)
	decodeErr := decoder.Decode(&req.Request)
	if decodeErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Error reading request body", decodeErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	conn, dberr := s.DB.Conn(ctx)
	if dberr != nil {
		common.HandleError(ctx, w, common.InternalError, "Database connection could not be retrieved", dberr, s.genCallback.MapError)
		return
	}

	defer conn.Close()
	makePaymentStmt, dberr := conn.PrepareContext(ctx, `
		UPDATE Account
		SET    balance = balance - ?
		WHERE  accountId = 1
		`)
	if dberr != nil {
		common.HandleError(ctx, w, common.InternalError, "could not parse the sql query with the name makePayment", dberr, s.genCallback.MapError)
		return
	}

	tx, dberr := conn.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if dberr != nil {
		common.HandleError(ctx, w, common.DownstreamUnavailableError, "DB Transaction could not be created", dberr, s.genCallback.MapError)
		return
	}

	client := PostPayClient{
		VisaPostPay:       s.visaVisaService.PostPay,
		MastercardPostPay: s.mastercardMastercardService.PostPay,

		Conn:        conn,
		MakePayment: makePaymentStmt,
	}

	paymentresponse, err := s.serviceInterface.PostPay(ctx, &req, client)
	if err != nil {
		tx.Rollback()
		common.HandleError(ctx, w, common.DownstreamUnexpectedResponseError, "Downstream failure", err, s.genCallback.MapError)
		return
	}

	commitErr := tx.Commit()
	if commitErr != nil {
		common.HandleError(ctx, w, common.InternalError, "Failed to commit the transaction", commitErr, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, paymentresponse)
}
